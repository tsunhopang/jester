"""End-to-end tests for SMC Random Walk sampler.

SMC-RW is the production-ready, recommended sampler.
These tests verify the full pipeline: config -> sampler.sample() -> SamplerOutput.
"""

import pytest
import jax
import jax.numpy as jnp

from jesterTOV.inference.config.schema import InferenceConfig
from jesterTOV.inference.run_inference import (
    setup_prior,
    setup_transform,
    setup_likelihood,
    determine_keep_names,
)
from jesterTOV.inference.samplers.factory import create_sampler

from .conftest import validate_sampler_output, NEP_PARAMS


@pytest.mark.slow
@pytest.mark.integration
@pytest.mark.e2e
class TestSMCRandomWalkE2E:
    """End-to-end tests for SMC-RW sampler."""

    def test_smc_rw_prior_only_full_pipeline(self, smc_rw_prior_config, e2e_temp_dir):
        """Test full SMC-RW pipeline with prior-only likelihood (cheapest test).

        This exercises:
        - Config loading and validation
        - Prior setup
        - Transform setup (MetaModel)
        - Likelihood setup (zero + constraints_eos)
        - Sampler creation via factory
        - Full sampling run
        - SamplerOutput generation
        """
        # Create config from dict
        config = InferenceConfig(**smc_rw_prior_config)

        # Setup components (following run_inference.py flow)
        prior = setup_prior(config)
        keep_names = determine_keep_names(config, prior)
        transform = setup_transform(config, prior=prior, keep_names=keep_names)
        likelihood = setup_likelihood(config, transform)

        # Create sampler via factory
        sampler = create_sampler(
            config=config.sampler,
            prior=prior,
            likelihood=likelihood,
            likelihood_transforms=[transform],
            seed=config.seed,
        )

        # Run sampling
        key = jax.random.PRNGKey(config.seed)
        sampler.sample(key)

        # Get output via standardized interface
        output = sampler.get_sampler_output()

        # Validate output structure
        validate_sampler_output(output, expected_params=NEP_PARAMS, min_samples=50)

        # SMC-specific: check weights in metadata
        assert "weights" in output.metadata, "SMC output missing weights"

        # Validate weights sum to ~1 (normalized)
        weights = output.metadata["weights"]
        assert jnp.isclose(
            jnp.sum(weights), 1.0, atol=0.01
        ), f"Weights don't sum to 1: {jnp.sum(weights)}"

    def test_smc_rw_chieft_full_pipeline(self, smc_rw_chieft_config, e2e_temp_dir):
        """Test full SMC-RW pipeline with chiEFT likelihood.

        This exercises the realistic use case with:
        - MetaModel+CSE transform
        - chiEFT likelihood (integrates EOS against constraint bands)
        - EOS constraint checking
        """
        config = InferenceConfig(**smc_rw_chieft_config)

        prior = setup_prior(config)
        keep_names = determine_keep_names(config, prior)
        transform = setup_transform(config, prior=prior, keep_names=keep_names)
        likelihood = setup_likelihood(config, transform)

        sampler = create_sampler(
            config=config.sampler,
            prior=prior,
            likelihood=likelihood,
            likelihood_transforms=[transform],
            seed=config.seed,
        )

        key = jax.random.PRNGKey(config.seed)
        sampler.sample(key)

        output = sampler.get_sampler_output()

        # For CSE, we have NEP params + nbreak + CSE grid params
        # The CSE grid params are auto-generated by prior parser
        assert "K_sat" in output.samples
        assert "nbreak" in output.samples

        # Should have finite samples in valid ranges
        for param, arr in output.samples.items():
            assert jnp.isfinite(arr).all(), f"Parameter {param} has non-finite values"

    def test_smc_rw_produces_valid_posterior(self, smc_rw_prior_config, e2e_temp_dir):
        """Test that SMC-RW produces samples in prior bounds."""
        config = InferenceConfig(**smc_rw_prior_config)

        prior = setup_prior(config)
        keep_names = determine_keep_names(config, prior)
        transform = setup_transform(config, prior=prior, keep_names=keep_names)
        likelihood = setup_likelihood(config, transform)

        sampler = create_sampler(
            config=config.sampler,
            prior=prior,
            likelihood=likelihood,
            likelihood_transforms=[transform],
            seed=config.seed,
        )

        key = jax.random.PRNGKey(config.seed)
        sampler.sample(key)

        output = sampler.get_sampler_output()

        # Check samples are within prior bounds
        # K_sat: [150, 300]
        assert jnp.all(output.samples["K_sat"] >= 150.0)
        assert jnp.all(output.samples["K_sat"] <= 300.0)

        # L_sym: [10, 200]
        assert jnp.all(output.samples["L_sym"] >= 10.0)
        assert jnp.all(output.samples["L_sym"] <= 200.0)

    def test_smc_rw_deterministic_with_seed(self, smc_rw_prior_config, e2e_temp_dir):
        """Test that SMC-RW is deterministic given same seed."""
        config = InferenceConfig(**smc_rw_prior_config)

        # Run twice with same seed
        results = []
        for _ in range(2):
            prior = setup_prior(config)
            keep_names = determine_keep_names(config, prior)
            transform = setup_transform(config, prior=prior, keep_names=keep_names)
            likelihood = setup_likelihood(config, transform)

            sampler = create_sampler(
                config=config.sampler,
                prior=prior,
                likelihood=likelihood,
                likelihood_transforms=[transform],
                seed=config.seed,
            )

            key = jax.random.PRNGKey(config.seed)
            sampler.sample(key)
            results.append(sampler.get_sampler_output())

        # Compare first sample of K_sat
        assert jnp.allclose(
            results[0].samples["K_sat"][:10],
            results[1].samples["K_sat"][:10],
            atol=1e-6,
        ), "SMC-RW not deterministic with same seed"
